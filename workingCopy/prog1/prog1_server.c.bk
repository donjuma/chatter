// Omar Juma
// Jason Mueller
// Updated last: January 21, 2015
// CSCI 367, Winter 2015
// Program 0

/* server.c - code for example server program that uses TCP */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>

#define QLEN 6 /* size of request queue */
int visits = 0; /* counts client connections */

/*------------------------------------------------------------------------
* Program: server
*
* Purpose: allocate a socket and then repeatedly execute the following:
* (1) wait for the next connection from a client
* (2) send a short message to the client
* (3) close the connection
* (4) go back to step (1)
*
* Syntax: server [ port ]
*
* port - protocol port number to use
*
* Note: The port argument is optional. If no port is specified,
* the server uses the default given by PROTOPORT.
*
*------------------------------------------------------------------------
*/

int takeTurn(char *board, int player, const char *PIECES){
   int row, col = 0;
   printf("Player %d (%c):\nEnter number coordinate: ", player + 1, PIECES[player]);

   while(1){
      if(1 != scanf("%d", &col) || col < 1 || col > 7 ){
         while(getchar() != '\n');
         puts("Number out of bounds! Try again.");
      } else {
         break;
      }
   }
   col--;

   for(row = BOARD_ROWS - 1; row >= 0; row--){
      if(board[BOARD_COLS * row + col] == ' '){
         board[BOARD_COLS * row + col] = PIECES[player];
         return 1;
      }
   }
   return 0;

}
int checkWin(char *board){
    return (horizontalCheck(board) || verticalCheck(board) || diagonalCheck(board));

}
int checkFour(char *board, int a, int b, int c, int d){
    return (board[a] == board[b] && board[b] == board[c] && board[c] == board[d] && board[a] != ' ');

}
int horizontalCheck(char *board){
    int row, col, idx;
    const int WIDTH = 1;

    for(row = 0; row < BOARD_ROWS; row++){
       for(col = 0; col < BOARD_COLS - 3; col++){
          idx = BOARD_COLS * row + col;
          if(checkFour(board, idx, idx + WIDTH, idx + WIDTH * 2, idx + WIDTH * 3)){
             return 1;
          }
       }
    }
    return 0;

}
int verticalCheck(char *board){
    int row, col, idx;
    const int HEIGHT = 7;

    for(row = 0; row < BOARD_ROWS - 3; row++){
       for(col = 0; col < BOARD_COLS; col++){
          idx = BOARD_COLS * row + col;
          if(checkFour(board, idx, idx + HEIGHT, idx + HEIGHT * 2, idx + HEIGHT * 3)){
              return 1;
          }
       }
    }
    return 0;

}
int diagonalCheck(char *board){
   int row, col, idx, count = 0;
   const int DIAG_RGT = 6, DIAG_LFT = 8;

   for(row = 0; row < BOARD_ROWS - 3; row++){
      for(col = 0; col < BOARD_COLS; col++){
         idx = BOARD_COLS * row + col;
         if(count <= 3 && checkFour(board, idx, idx + DIAG_LFT, idx + DIAG_LFT * 2, idx + DIAG_LFT * 3) || count >= 3 && checkFour(board, idx, idx + DIAG_RGT, idx + DIAG_RGT * 2, idx + DIAG_RGT * 3)){
            return 1;
         }
         count++;
      }
      count = 0;
   }
   return 0;

}


int standard_mode(int sd2, int sd3){
    char buf[1000];     //Initialize buffer for communication

    buf[0] = 'g';
    write(sd2, &buf[0], sizeof(buf[0]));
    sleep(1);
    write(sd3, &buf[0], sizeof(buf[0]));
/*
    while(0) {
        int conn_status = read(sd2, &current_guess, sizeof(current_guess));
        //Check for premature disconnect.
        if (conn_status <= 0) {
            close(sd2);
            break;
        }
        current_guess = ntohl(current_guess);
        current_distance = abs(secret - current_guess);

        if (current_guess == secret){
            buf[0] = '0';
        }
        else if ( (current_distance - previous_distance) == 0) {
            buf[0] = '3';
        }
        else if ( (current_distance - previous_distance) < 0 ){
            buf[0] = '1';
        }
        else if ( (current_distance - previous_distance) > 0 ){
            buf[0] = '2';
        }

        write(sd2, &buf[0], sizeof(buf[0]));
        previous_distance = current_distance;

        if (buf[0] == '0') {
            close(sd2);
            break;
        }
    } */
    exit(0);
}


int main(int argc, char **argv) {
    struct protoent *ptrp; /* pointer to a protocol table entry */
    struct sockaddr_in sad; /* structure to hold server's address */
    struct sockaddr_in cad; /* structure to hold client's address */
    int sd, sd2, sd3; /* socket descriptors */
    int port; /* protocol port number */
    int alen; /* length of address */
    char buf[1000]; /* buffer for string the server sends */
    char game_type[4]; //Identifier of the selected game mode
    pid_t pid;
    if( argc != 3 ) {
        fprintf(stderr,"Error: Wrong number of arguments\n");
        fprintf(stderr,"usage:\n");
        fprintf(stderr,"./server server_port game_type\n");
        exit(EXIT_FAILURE);
    }

    memset((char *)&sad,0,sizeof(sad)); /* clear sockaddr structure */
    sad.sin_family = AF_INET; /* set family to Internet */
    sad.sin_addr.s_addr = INADDR_ANY; /* set the local IP address */

    port = atoi(argv[1]); /* convert argument to binary */

    if (strcmp(argv[2], "standard") == 0) {
        printf("Normal selected\n");
        game_type[0] = 'S';
    } else if (strcmp(argv[2], "popout") == 0) {
        printf("Popout selected\n");
        game_type[0] = 'P';
    } else if (strcmp(argv[2], "antistack") == 0) {
        printf("Antistack selected\n");
        game_type[0] = 'K';
    } else{
        fprintf(stderr, "Error: Invalid Game Type %s\n", argv[2]);
        exit(0);
    }

    printf("Game mode selected: %s\n", argv[2]);

    if (port > 0) { /* test for illegal value */
        sad.sin_port = htons((u_short)port);
    } else { /* print error message and exit */
        fprintf(stderr,"Error: Bad port number %s\n",argv[1]);
        exit(EXIT_FAILURE);
    }

    /* Map TCP transport protocol name to protocol number */
    if ( ((long int)(ptrp = getprotobyname("tcp"))) == 0) {
        fprintf(stderr, "Error: Cannot map \"tcp\" to protocol number");
        exit(EXIT_FAILURE);
    }

    /* Create a socket */
    sd = socket(PF_INET, SOCK_STREAM, ptrp->p_proto);
    if (sd < 0) {
        fprintf(stderr, "Error: Socket creation failed\n");
        exit(EXIT_FAILURE);
    }

    /* Bind a local address to the socket */
    if (bind(sd, (struct sockaddr *)&sad, sizeof(sad)) < 0) {
        fprintf(stderr,"Error: Bind failed\n");
        exit(EXIT_FAILURE);
    }

    /* Specify size of request queue */
    if (listen(sd, QLEN) < 0) {
        fprintf(stderr,"Error: Listen failed\n");
        exit(EXIT_FAILURE);
    }

    /* Main server loop - accept and handle requests */
    for (;;) {
        buf[0] = 0;
        alen = sizeof(cad);
        if ( (sd2=accept(sd, (struct sockaddr *)&cad, &alen)) < 0) {
            fprintf(stderr, "Error: Accept failed\n");
            exit(EXIT_FAILURE);
        }
        write(sd2, &game_type[0], sizeof(game_type[0])); //Send player 1 game mode
        sleep(1);
        buf[0] = '2';
        write(sd2, &buf[0], sizeof(buf[0])); //Inform Player 1 we are waiting for player 2

        if ( (sd3=accept(sd, (struct sockaddr *)&cad, &alen)) < 0) {
            fprintf(stderr, "Error: Accept failed\n");
            exit(EXIT_FAILURE);
        }
        write(sd3, &game_type[0], sizeof(game_type[0])); //Send player 2 game mode
        sleep(1);
        buf[0] = '1';
        write(sd3, &buf[0], sizeof(buf[0])); //Inform Player 2 that we are ready

        signal(SIGCHLD,SIG_IGN);
        /*Child process logic  */
        pid = fork();

        if (pid < 0){
            printf("Error in fork\n");
        }

        else if (pid == 0) {
            close(sd);

            standard_mode(sd2, sd3);
          /*  while(1) {
                int conn_status = read(sd2, &current_guess, sizeof(current_guess));
                //Check for premature disconnect.
                if (conn_status <= 0) {
                    close(sd2);
                    break;
                }
                current_guess = ntohl(current_guess);
                current_distance = abs(secret - current_guess);

                if (current_guess == secret){
                    buf[0] = '0';
                }
                else if ( (current_distance - previous_distance) == 0) {
                    buf[0] = '3';
                }
                else if ( (current_distance - previous_distance) < 0 ){
                    buf[0] = '1';
                }
                else if ( (current_distance - previous_distance) > 0 ){
                    buf[0] = '2';
                }

                write(sd2, &buf[0], sizeof(buf[0]));
                previous_distance = current_distance;

                if (buf[0] == '0') {
                    close(sd2);
                    break;
                }
            } */
            exit(0);
        }
        else{
            close(sd2);
        }
    }
}
